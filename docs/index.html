<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Simple FeatureLayer</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- Load Leaflet from CDN -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
    integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
    crossorigin="" />
  <link rel="stylesheet" href="css/MarkerCluster.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-geosearch/3.0.6/geosearch.css" />
  <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
    integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
    crossorigin=""></script>
  <script src="js/leaflet.markercluster.js"></script>
  <script src="js/Leaflet.Control.Custom.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-geosearch/3.0.6/bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet.geodesic"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    .inputs {
      -webkit-appearance: none;
      background-color: #fafafa;
      border: 1px solid #cacece;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05), inset 0px -15px 10px -12px rgba(0, 0, 0, 0.05);
      padding: 9px;
      border-radius: 3px;
      display: inline-block;
      position: relative;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      right: 0;
      left: 0;
    }
  </style>
</head>

<body>

  <div id="map"> </div>

  <script>
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(function (position) {
        console.log('--- Your Position: ---');
        console.log('Lat: ' + position.coords.latitude);
        latit = position.coords.latitude;
        console.log('Long: ' + position.coords.longitude);
        longit = position.coords.longitude;
        console.log('---------------------');

        addmap(latit, longit)

      })
    }
    function addmap(latit, longit) {

      var map = L.map('map');
      map.setZoom(18)
      /* map.fitBounds([
         [28.798466742681587, 76.11983078002931],
         [28.808466742681587, 76.12983078002911]
       ]);*/
      console.log('Lat: ' + latit);
      map.setView([latit, longit], 17);
      var di = new L.LatLng(latit, longit);
      var drag = new L.LatLng(latit + 0.001000000000000000, longit + 0.001000000000000000);
      var geoIcon = new L.Icon({
              iconSize: [37, 37],
              iconAnchor: [13, 27],
              popupAnchor: [1, -24],
              iconUrl: 'icons/geo.png'
            });
      var A = L.marker(di, { draggable: true,icon: geoIcon }).bindTooltip('Hi There!').addTo(map);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(map);

      var GeoSearchControl = window.GeoSearch.GeoSearchControl;
      var OpenStreetMapProvider = window.GeoSearch.OpenStreetMapProvider;
      var provider = new OpenStreetMapProvider({
        params: {
          countrycodes: 'in',
        },
      });

      //  Define search controls
      var searchControl = new GeoSearchControl({
        provider: provider,
        retainZoomLevel: true,
        showMarker: true,
        marker: {
          draggable: true
        },
        autoClose: true,
        keepResult: true,
      });

      // Add searchbar to the map
      map.addControl(searchControl);
   //   var clusters = L.markerClusterGroup()
   let coverage = L.layerGroup()
      var myData;

      function onPoint(geoJsonPoint, latlng) {
        console.log("pomt")


        /*  if (geoJsonPoint.properties.Sitetype == 'GBM') {
            console.log("eee")
            var smallIcon = new L.Icon({
              iconSize: [27, 27],
              iconAnchor: [13, 27],
              popupAnchor: [1, -24],
              iconUrl: 'icons/GSMtower.png'
            });
          }
    
          if (geoJsonPoint.properties.Sitetype == 'GBT') {
            var smallIcon = new L.Icon({
              iconSize: [27, 27],
              iconAnchor: [13, 27],
              popupAnchor: [1, -24],
              iconUrl: 'icons/UMTStower.png'
            });
          }
    
          if (geoJsonPoint.properties.Sitetype == 'RTP') {
            var smallIcon = new L.Icon({
              iconSize: [27, 27],
              iconAnchor: [13, 27],
              popupAnchor: [1, -24],
              iconUrl: 'icons/LTEradiotower.png'
            });
          } else {
    
            var smallIcon = new L.Icon({
              iconSize: [27, 27],
              iconAnchor: [13, 27],
              popupAnchor: [1, -24],
              iconUrl: 'icons/LTEradiotower.png'
            });
    
          }*/

        // var marker = L.marker(latlng, { icon: smallIcon })
        var marker = L.marker(latlng)
     
        if (geoJsonPoint.properties.Sitetype == 'GBM' || geoJsonPoint.properties.Sitetype == 'LPBTS') {
          const geodesiccircle = new L.GeodesicCircle(latlng, {
          radius: 1*1000,  // 3000km in meters
        });
        coverage.addLayer(geodesiccircle)
        }

        if (geoJsonPoint.properties.Sitetype == 'COW(GBT)' || geoJsonPoint.properties.Sitetype == 'RTP' || geoJsonPoint.properties.Sitetype == 'Wall mount') {
          const geodesiccircle = new L.GeodesicCircle(latlng, {
          radius: 2*1000,  // 3000km in meters
        });
        coverage.addLayer(geodesiccircle)
        }

        if (geoJsonPoint.properties.Sitetype == 'GBT') {
          const geodesiccircle = new L.GeodesicCircle(latlng, {
          radius: 4*1000,  // 3000km in meters
        });
        coverage.addLayer(geodesiccircle)
        }

        if (geoJsonPoint.properties.Sitetype == 'LPBTS') {
          const geodesiccircle = new L.GeodesicCircle(latlng, {
          radius: 1*1000,  // 3000km in meters
        });
        coverage.addLayer(geodesiccircle)
        }

        if (geoJsonPoint.properties.Sitetype == 'RTT') {
          const geodesiccircle = new L.GeodesicCircle(latlng, {
          radius: 3*1000,  // 3000km in meters
        });
        coverage.addLayer(geodesiccircle)
        }

        
        marker.bindPopup("LSA : " + geoJsonPoint.properties.LSA + "<br/>SiteType : " + geoJsonPoint.properties.Sitetype + "<br/>District : " + geoJsonPoint.properties.District);
        //clusters.addLayer(marker);
        return marker;
      }





      /*  var afterFetch = function (data) {
          clusters.clearLayers()
         
          myData = data;
    
        }*/


      function updateCheckboxStates() {
        checkboxStates = {
          years: [],
          eventTypes: []
        }

        for (let input of document.querySelectorAll('input')) {
          if (input.checked) {
            switch (input.className) {
              case 'event-type': checkboxStates.eventTypes.push(input.value); break

            }
          }
        }
      }
      let checkboxStates

      $.getJSON("https://kitsihbboxapi.herokuapp.com/data?lat=" + latit + "&&long=" + longit, function (data) {
        // Define the geojson layer and add it to the map
        myData = data;
        console.log(myData)
        L.geoJSON(data, {
          pointToLayer: onPoint,
          filter: (feature) => {
            const isEventTypeChecked = checkboxStates.eventTypes.includes(feature.properties.Sitetype)
            return isEventTypeChecked
          }
        }).addTo(map);
      });
      var button=0;
      
      L.control.custom({
    position: 'topright',
    content: '<div class="inputs" id="event-types">' +
      '<button type="button">Coverage</button>'+
      '</div>',
      style   :
    {
        margin: '10px',
        padding: '0px 0 0 0',
        cursor: 'pointer',
    },
    datas   :
    {
        'foo': 'bar',
    },
    events:
    {
        click: function(data)
        {
          console.log("function called")
          console.log(button)
          if(button==0)
          {
           
            coverage.addTo(map)
            button=1;
          }else
          {
            map.removeLayer(coverage)
            button=0
          }
          

        }
    }
  
  }).addTo(map);

 //     map.addLayer(clusters);
      L.control.custom({
        position: 'topright',
        content: '<div class="inputs" id="event-types">' +
          '<input type="checkbox" class="event-type" name="GBM" value="GBM" checked="true">' +
          '<label for="funfair">GBM</label>' +
          '<input type="checkbox" class="event-type" name="GBT" value="GBT" checked="true">' +
          '<label for="trade">GBT</label>' +
          '<input type="checkbox" class="event-type" name="RTP" value="RTP" checked="true">' +
          '<label for="trade">RTP</label>' +
          '<input type="checkbox" class="event-type" name="RTT" value="RTT" checked="true">' +
          '<label for="trade">RTT</label>' +
          '<input type="checkbox" class="event-type" name="LPBTS" value="LPBTS" checked="true">' +
          '<label for="trade">LPBTS</label>' +
          '</div>',

        style:
        {
          margin: '15px',
          padding: '0px 0 0 0',
          cursor: 'pointer',
        },
        events:
        {
          click: function (data) {
            for (let input of document.querySelectorAll('input')) {
              //Listen to 'change' event of all inputs
              input.onchange = (e) => {
               // clusters.clearLayers()
               map.eachLayer(function(layer) {
  if (!!layer.toGeoJSON) {
    map.removeLayer(layer);
  }
});
                updateCheckboxStates()
                //  clusters.addData(myData) 
              
                var a = L.geoJSON(myData, {
                  pointToLayer: onPoint,
                  filter: (feature) => {
                    const isEventTypeChecked = checkboxStates.eventTypes.includes(feature.properties.Sitetype)
                    return isEventTypeChecked
                  }
                }).addTo(map);
              //  map.addLayer(clusters);
              }



            }


          },
        }
      })
        .addTo(map)

      updateCheckboxStates();

      map.on('geosearch/showlocation', (result) => {
        console.log("geosearch location")
        console.log(result.location.x)
   //     clusters.clearLayers();
        map.setView([result.location.y, result.location.x], 17);
        $.getJSON("https://kitsihbboxapi.herokuapp.com/data?lat=" + result.location.y + "&&long=" + result.location.x, function (data) {
          // Define the geojson layer and add it to the map
          myData = data;
          console.log(myData)
          L.geoJSON(data, {
            pointToLayer: onPoint,
            filter: (feature) => {
              const isEventTypeChecked = checkboxStates.eventTypes.includes(feature.properties.Sitetype)
              return isEventTypeChecked
            }
          }).addTo(map);
        });

      //  map.addLayer(clusters);
      });


    }

  </script>

</body>

</html>
